import { InnerBlocks, RichText } from '@wordpress/block-editor';
import { Card, CardBody } from '@wordpress/components';
import ServerSideRender from '@wordpress/server-side-render';
import { useState } from '@wordpress/element';


import { switchComponents } from './switchComponents';

/**
 * This is basically the heart of the JS part of this Plugin.
 * It takes all the fields and information to create a user interface inside the editor.
 * 
 * @param {String} name 
 * @param {Object} fields like block attributes but with a label and a input
 * @param {Object} options options like in wp.blocks.registerBlockType just without attributes
 * @param {Array} children optional template for InnerBlocks
 */
function registerHelper( name, fields, options, children ) {
  const origAttributes = {};

  for (const [fieldName, field] of Object.entries(fields)) {
    // copy relevant parts of the fields object to generate attributes
    const newValue = {};
    newValue.type = field.type;
    newValue.default = field.default;
    
    origAttributes[fieldName] = newValue;
  }

  const edit = (props) => {
		const { attributes, setAttributes, isSelected } = props;
		const [ height, setHeight ] = useState(0);

		return (
			<div
				style={{minHeight: height }}
				onMouseDown={(e) => { 
					/* this should prevent scroll position jumping but there is probably a better way to do this */
					if (isSelected) return;
					e.currentTarget.style.minHeight = null;
					const currentHeight = e.currentTarget.offsetHeight;
					e.currentTarget.style.minHeight = currentHeight + 'px';
					setHeight( currentHeight );
				}}
			>
					{/* show serversiderender only if it has no children, ssr does not work with children here */}
					{( isSelected || children ) ? (
						<Card style={{ background: (!isSelected && !children) && 'transparent'}}>
							<CardBody>
								<label style={{fontSize: '10px'}}>Block: {options.title}</label> 
								{Object.entries(fields).map( ([fieldName, field]) => {
									return switchComponents(field, setAttributes, fieldName, attributes, props);
								})}

								{ children && (
									<div style={{border: '1px dashed grey', padding: '10px'}} >
										<InnerBlocks
											allowedBlocks={ children }
											orientation='horizontal'
											renderAppender={ InnerBlocks.ButtonBlockAppender }
										/>
									</div>
								)}
							</CardBody>
						</Card>
					):(
						<ServerSideRender
							block={ name }
							attributes={ { ...attributes } }
						/>
					)
					}
			</div>
			)
  }
  
  const blockObj = {
    edit,
    save: ( {attributes} ) => {
			return (
				children ? 
				<InnerBlocks.Content /> : 
				 /* 	Fallback Content to be saved inside the database/content for example for SEO Plugins etc.
							also important if you choose to disable the block or if it stops working */ 
				(
					<div>
						{Object.entries(fields).map( ([fieldName, field]) => {
								switch (field.input) {
									// for some fields it is likely, that there should be output
									case 'text': 
										if (typeof field.selector === "string") {
											// TODO: check if it is a valid tag
											const CustomTag = field.selector;
											return <CustomTag>{attributes[fieldName]}</CustomTag>;
										} else {
											return <p>{attributes[fieldName]}</p>;
										};
									case 'image': 
										return (
											<img 
												src={(typeof attributes[fieldName] === "object") && attributes[fieldName].url}
												alt={(typeof attributes[fieldName] === "object") && attributes[fieldName].alt}
											/>
										);
									case 'richText': return (<RichText.Content tagName="p" value={attributes[fieldName]} />);
									default: return null; // by default don't output anything 
								}
						})}
					</div>
				)
				
			) // default: for server side rendered blocks, can be overwritten
    },
    ...options,
    attributes: origAttributes // ALWAYS uses attributes generated by fields object
  }
	wp.blocks.registerBlockType(name, blockObj);
}

/**
 * Register All Blocks that are added with the PHP helper function add_fast_block
 * const fastBlockBlocks is made available with PHP
 */
Object.values(fastBlockBlocks).forEach( block => {
  registerHelper(block.name, block.fields, block.settings, block.children);
})
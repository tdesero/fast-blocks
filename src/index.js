import { InnerBlocks, RichText } from '@wordpress/block-editor';
import { Card, CardBody, CardHeader } from '@wordpress/components';
import ServerSideRender from '@wordpress/server-side-render';
import { useState } from '@wordpress/element';
import { registerBlockType } from '@wordpress/blocks';


import { switchComponents } from './switchComponents';

import './editor.scss';

/**
 * Register Blocks and automatically create an Editor UI
 * 
 * @param {string} name - Block name with slug e.g. my-slug/my-block
 * @param {Object} fields - All block attributes with a label and a input
 * 
 * TODO: learn how to document the following
 * @param fields.fieldName 
 * @param fields.fieldName.type
 * @param fields.fieldName.default
 * @param fields.fieldName.label
 * @param fields.fieldName.input 
 * @param fields.fieldName[selector] - optional selector
 * 
 * @param {Object} options - All options like in wp.blocks.registerBlockType but without(!) attributes: @see https://developer.wordpress.org/block-editor/reference-guides/block-api/block-registration/
 * @param {array} [children] - Optional template for InnerBlocks
 */
function registerHelper( name, fields, options, children ) {
  const blockAttributes = {};

  for (const [fieldName, field] of Object.entries(fields)) {
    // copy relevant parts of the fields object to generate attributes
    const newValue = {};
    newValue.type = field.type;
    newValue.default = field.default;
    
    blockAttributes[fieldName] = newValue;
  }

  const edit = (props) => {
		const { attributes, isSelected } = props;
		const [ height, setHeight ] = useState(0);

		return (
			<div
				style={{ minHeight: height }}
				onMouseDown={(e) => { 
					/* this should prevent scroll position jumping but there is probably a better way to do this */
					if (isSelected) return;
					e.currentTarget.style.minHeight = null;
					const currentHeight = e.currentTarget.offsetHeight;
					e.currentTarget.style.minHeight = currentHeight + 'px';
					setHeight( currentHeight );
				}}
			>
					{/* show serversiderender only if it has no children, ssr does not work with children here */}
					{( isSelected || children ) ? 
						(
							<Card className='fbl_card'>
								<CardHeader className='fbl_block-title'>Block: {options.title}</CardHeader>
								<CardBody style={{padding: '16px 14px'}}>
									{Object.entries(fields).map( ([fieldName, field]) => {
										return switchComponents(props, fieldName, field);
									})}

									{ children && (
										<div style={{border: '1px dashed grey', padding: '10px'}} >
											<InnerBlocks
												allowedBlocks={ children }
												orientation='horizontal'
												renderAppender={ InnerBlocks.ButtonBlockAppender }
											/>
										</div>
									)}
								</CardBody>
							</Card>
						) :
						(
							<ServerSideRender
								block={ name }
								attributes={ { ...attributes } }
							/>
						)
					}
			</div>
			)
  }
  
  const blockObj = {
    edit,
    save: ( {attributes} ) => {
			return (
				children ? 
				<InnerBlocks.Content /> :
				(
					<div>
						{Object.entries(fields).map( ([fieldName, field]) => {
								/* Fallback Content to be saved inside the database/content for example for SEO Plugins etc.
								also important if you choose to disable the block or if it stops working */ 

								switch (field.input) {
									// for some fields it is likely, that there should be output
									case 'text': 
										if (typeof field.selector === "string") {
											// TODO: check if it is a valid tag
											const CustomTag = field.selector;
											return <CustomTag>{attributes[fieldName]}</CustomTag>;
										} else {
											return <p>{attributes[fieldName]}</p>;
										};
									case 'image': 
										return (
											<img 
												src={(typeof attributes[fieldName] === "object") && attributes[fieldName].url}
												alt={(typeof attributes[fieldName] === "object") && attributes[fieldName].alt}
											/>
										);
									case 'richText': return (<RichText.Content tagName="p" value={attributes[fieldName]} />);
									default: return null; // by default don't output anything 
								}
						})}
					</div>
				)
			) // default: for server side rendered blocks, can be overwritten
    },
    ...options,
    attributes: blockAttributes // ALWAYS uses attributes generated by fields object
  }
	registerBlockType(name, blockObj);
}

/**
 * Register All Blocks that are added with the PHP helper function add_fast_block
 * const fastBlockBlocks is made available with PHP
 */
Object.values(fastBlockBlocks).forEach( block => {
  registerHelper(block.name, block.fields, block.settings, block.children);
})